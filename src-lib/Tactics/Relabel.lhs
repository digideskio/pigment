Relabelling
===========

> {-# LANGUAGE GADTs, TypeOperators, TupleSections, PatternGuards,
>              FlexibleContexts, PatternSynonyms, ScopedTypeVariables,
>              FlexibleInstances, MultiParamTypeClasses #-}

> module Tactics.Relabel where

> import Control.Applicative
> import Control.Monad
> import Control.Monad.State
> import Data.Foldable hiding (foldr)
> import Data.Traversable

> import Control.Error

> import Evidences.Tm
> import Evidences.Utilities
> import Evidences.Eval
> import Evidences.Operators
> import Evidences.DefinitionalEquality
> import Evidences.TypeChecker
> import ProofState.Edition.ProofContext
> import ProofState.Edition.ProofState
> import ProofState.Edition.GetSet
> import ProofState.Edition.Navigation
> import ProofState.Edition.Scope
> import ProofState.Interface.ProofKit
> import ProofState.Interface.Definition
> import ProofState.Interface.Solving
> import ProofState.Interface.Lifting
> import ProofState.Interface.Parameter
> import DisplayLang.DisplayTm
> import DisplayLang.Name
> import Elaboration.ElabMonad
> import Elaboration.Elaborator
> import Kit.BwdFwd
> import Kit.MissingLibrary

The `partApplyREF` command takes a reference and list of argument values
(as generated by `splitSpine`, and splits them into a term in local
scope (i.e. the reference applied to the shared parameters) and a list
of additional arguments.

> partApplyREF :: forall e.
>                 ErrorStack (ProofStateT e) e
>              => REF
>              -> [VAL]
>              -> ProofStateT e (EXTM :=>: VAL :<: TY, [VAL])
> partApplyREF r@(_ := DECL :<: _) as = return (P r :=>: NP r :<: pty r, as)
> partApplyREF r as = do
>     es <- getGlobalScope
>     help (pty r) B0 (paramREFs es) as
>   where
>     help :: TY -> Bwd REF -> [REF] -> [VAL] -> ProofStateT e (EXTM :=>: VAL :<: TY, [VAL])
>     help (PI s t) cs (r:rs) (NP x : as) | r == x =
>         help (t $$ A (NP x)) (cs :< r) rs as
>     help ty cs [] as = do
>         let t = P r $## fmap NP cs
>         return (t :=>: evTm t :<: ty, as)
>     help ty cs rs as =
>         let stack :: StackError e
>             stack = stackItem
>                 [ errMsg "partApplyREF: failed on type "
>                 , errTyVal (ty :<: SET)
>                 , errMsg " with refs "
>                 , map ErrorREF rs
>                 ]
>         in throwStack stack

A relabelling is a map from refrences to strings, giving a new name that
should be used for the reference.

> type Relabelling = Bwd (REF, String)

The `relabel` command changes the names of the pattern variables in a
programming problem. It takes an unelaborated application corresponding
to the programming problem, matches it against the existing arguments to
determine the renaming, and refines the proof state appropriately.

> relabel :: DExTmRN -> ProofState ()
> relabel (DP [(f, Rel 0)] ::$ ts) = do
>     tau' :=>: tau <- getHoleGoal
>     case tau of
>         LABEL (N l) ty -> do
>             let Just (r, as) = splitSpine l
>             unless (f == refNameAdvice r) $
>                 throwDTmStr "relabel: mismatched function name!"
>             ts' <- traverse unA ts
>             (_ :<: rty, as') <- partApplyREF r as
>             rl   <- execStateT (relabelArgs rty ts' as') B0
>             es   <- getEntriesAbove
>             refineProofState (liftType es tau') (N .($:$ paramSpine es))
>             introLambdas rl (paramREFs es)
>         _ -> throwDTmStr "relabel: goal is not a labelled type!"
> relabel _ = throwDTmStr "relabel: malformed relabel target!"

Once the refinement has been made, we need to introduce the hypotheses
using their new names. The `introLambdas` command takes a relabelling
and the references from the entries that were abstracted over, and
introduces a hypothesis corresponding to each reference with the
reference's new name.

> introLambdas :: Relabelling -> [REF] -> ProofState ()
> introLambdas rl [] = return ()
> introLambdas rl (x:xs) = lambdaParam newName >> introLambdas rl xs
>   where
>     newName = case find ((x ==) . fst) rl of
>                   Just (_, s)  -> s
>                   Nothing      -> refNameAdvice x

> unA :: (Monad m, ErrorStack m DInTmRN) => Elim a -> m a
> unA (A a)  = return a
> unA _      =
>     let stack :: StackError DInTmRN
>         stack = errMsgStack "unA: not an A!"
>     in throwStack stack

> extendRelabelling :: REF -> String -> StateT Relabelling (ProofStateT a) ()
> extendRelabelling r s = do
>     rl <- get
>     case find ((r ==) . fst) rl of
>         Nothing                   -> put (rl :< (r, s))
>         Just (_, t)  | s == t     -> return ()
>                      | otherwise  -> throwState $ stackItem
>             [ errMsg ("relabelValue: inconsistent names '" ++ s ++ "' and '" ++
>                    t ++ "' for")
>             , errRef r
>             ]

> throwState :: StackError b -> StateT a (ProofStateT b) c
> throwState = lift . throwStack

> relabelArgs :: TY -> [DInTmRN] -> [VAL] -> StateT Relabelling ProofState ()
> relabelArgs _ []  []   = return ()
> relabelArgs _ []  _    = throwState $ errMsgStack "relabel: too few arguments!"
> relabelArgs _ _   []   = throwState $ errMsgStack "relabel: too many arguments!"
> relabelArgs (PI s t) (w:ws) (a:as) = do
>     relabelValue (s :>: (w, a))
>     relabelArgs (t $$ A a) ws as
> relabelArgs ty ws as  = throwState $ stackItem
>     [ errMsg "relabel: unmatched\nty ="
>     , errTyVal (ty :<: SET)
>     , errMsg "\nas ="
>     , foldMap errVal as
>     ]

-- XXX(joel)
instance ErrorStack (StateT a (ProofStateT e)) e where
    throwStack = lift . throwT

> relabelValue :: (TY :>: (DInTmRN, VAL)) -> StateT Relabelling ProofState ()

If the value we are matching against is a stuck recursive call, we match
against the user-friendly label (which is what the user would expect)
rather than the horrible induction term.

> relabelValue (ty :>: (w, N (n :$ Call l))) = relabelValue (ty :>: (w, l))

If we are matching two parameters (applied to some arguments), we can
extend the relabelling and matching the arguments.

> relabelValue (ty :>: (DN (DP [(s, Rel 0)] ::$ ws), N n))
>   | Just (r, as) <- splitSpine n = do
>     (_ :<: ty, as')  <- lift $ partApplyREF r as
>     extendRelabelling r s
>     ws'              <- lift $ traverse unA ws
>     relabelArgs ty ws' as'

If the display term is an underscore then we make no changes to the
relabelling.

> relabelValue (ty :>: (DU, _)) = return ()

If the display term and value are both canonical, we halfzip them
together (ensuring the constructors match) and use `canTy` to match the
pieces.

> relabelValue (C cty :>: (DC w, C v)) = case halfZip w v of
>     Nothing -> throwState $ errMsgStack "relabelValue: mismatched constructors!"
>     Just wv -> (liftage fst $ canTy chev (cty :>: wv)) >> return ()
>   where
>     chev :: (TY :>: (DInTmRN, VAL)) ->
>                 StateT Relabelling (ProofStateT (DInTmRN, VAL)) (() :=>: VAL)
>     chev (ty :>: (w, v)) = do
>         liftage (\ t -> (t, error "erk")) $ relabelValue (ty :>: (w, v))
>         return (() :=>: v)
>     liftage :: (s -> t) -> StateT x (ProofStateT s) a
>                             -> StateT x (ProofStateT t) a
>     liftage = mapStateT . liftErrorState

Nothing else matches? We had better give up.

> relabelValue (ty :>: (w, v)) = lift $ throwErrorS
>     [ errMsg "relabel: can't match"
>     , errTm w
>     , errMsg "with"
>     , errTyVal (v :<: ty)
>     ]
