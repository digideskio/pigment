################################################################
# Configuration
################################################################

################
#### GHC

HC              = ~/haskell/haste-compiler/.cabal-sandbox/bin/hastec
HC_PACKAGE      = -hide-all-packages \
		  -package transformers-0.3.0.0 \
		  -package haste-compiler-0.4.3 \
		  -package mtl-2.2.1 \
		  -package pretty-1.1.1.1 \
		  -package base-4.7.0.1 \
		  $(HC_CABAL_PACKAGE)
HC_OPTS_DEV     = $(HC_PACKAGE)
HC_OPTS_TEST    = $(HC_PACKAGE) -fhpc
HC_OPTS_RELEASE = $(HC_PACKAGE) -O2
HC_OPTS_WARNING = $(HC_PACKAGE) -fwarn-unused-imports
HC_OPTS_PROFILE = $(HC_PACKAGE) -prof -auto-all
HC_OPTS         = $(HC_OPTS_DEV)
BUILD_MODE	= BUILD_DEV


################
#### PDFLaTeX

LATEXC = pdflatex
#LATEXOPTS = -interaction=nonstopmode


################################################################
# Configuration
################################################################

SRCS_KIT := $(wildcard Kit/*.lhs)

SRCS_COMPILER := $(wildcard Compiler/*.lhs)

SRCS_EVIDENCES := $(wildcard NameSupply/*.lhs) \
		  $(wildcard Evidences/*.lhs) \
		  $(wildcard Features/*.lhs)

SRCS_PFSTATE := $(wildcard ProofState/Structure/*.lhs) \
		$(wildcard ProofState/Movement/*.lhs) \
		$(wildcard ProofState/Edition/*.lhs) \
		$(wildcard ProofState/Interface/*.lhs)

SRCS_DISPLAYS := $(wildcard DisplayLang/*.lhs) \
	  	 $(wildcard Elaboration/*.lhs) \
		 $(wildcard Distillation/*.lhs) \
		 $(wildcard SourceLang/*.lhs)

SRCS_TACTICS := $(wildcard Tactics/*.lhs)

SRCS_COCHON := $(wildcard Cochon/*.lhs)

SRCS_RASCAL := $(wildcard Rascal/*.hs) Rascal.hs

SRCS_MAIN := $(wildcard *.lhs)

SRCS := $(SRCS_KIT) \
	$(SRCS_COMPILER) \
	$(SRCS_EVIDENCES) \
	$(SRCS_PFSTATE) \
	$(SRCS_DISPLAYS) $(SRCS_TACTICS) \
	$(SRCS_COCHON) $(SRCS_RASCAL) $(SRCS_MAIN)
OBJS := $(SRCS:.lhs=.o)

.SUFFIXES : .o .hs .hi .lhs .hc .s .hi-boot .lhs-boot .o-boot

################################################################
# Rules
################################################################

## Default rule:
#     * (build dependency graph)
#     * make Epigram binary
#     * make the literate document
all: Pig Epitome

web:
	hastec Main.lhs --with-js=react-stubs.js

## Dependency graph:
# Ask GHC to compute the dependency graph.
#
# This calls She on every source file, therefore it is painfully
# slow. Unless explicitly asked to, we avoid running it.
#
# The dependency graph is broken wrt. She aspects: the typical example
# is Features.lhs, which import code from Sigma for example. Changing
# Sigma.lhs causes the re-compilation of the (empty) file Sigma.lhs,
# without causing the re-compilation of Rules.lhs, for example.
depend : $(SRCS)
	$(HC) $(HC_PACKAGE) -M -dep-suffix '' -dep-makefile .depend $(SRCS)
dep : depend

# TODO(joel) - avoid rerunning she over a bunch of files repeatedly
# - why exactly does this happen?
# - because we're running --make over all the lhs files?
#
# stages:
# - build .depend
#   * afaik we're good up to here
# - run she over any files which have been modified more recently than their
#   corresponding .hspp
#   * can't really do this since she is called by ghc as it compiles a file
#   * give ghc a hint?
#   * make she smarter (don't run in this case)?
#
# .depend : $(SRCS)
# 	$(HC) $(HC_PACKAGE) -M -dep-suffix '' -dep-makefile .depend $(SRCS)


## Epigram object files:
#
# Let us abuse the power of separate compilation to make some kinda
# self-contained components. The idea here is to be able to
# (temporarily) break some parts of the system and not having to
# care. For instance, one could experiment with the Evidence language,
# hence breaking everything above. When the situation has stabilized,
# one can work bit by bit to get the whole tower to compile again.

kit: $(SRCS_KIT:.lhs=.o)
compiler: $(SRCS_COMPILER:.lhs=.o)
evidences: $(SRCS_EVIDENCES:.lhs=.o)
proofstate: $(SRCS_PFSTATE:.lhs=.o)
displays: $(SRCS_DISPLAYS:.lhs=.o)
tactics: $(SRCS_TACTICS:.lhs=.o)
cochon: $(SRCS_COCHON:.lhs=.o)
rascal: $(SRCS_RASCAL:.hs=.o)
main: $(SRCS_MAIN:.lhs=.o)

epigram: kit compiler evidences proofstate displays tactics cochon main

## Epigram:
# Link the Epigram binary. Rely on the dependency graph to compile the
# code. If the dependency graph doesn't exist or has changed, this
# will go wrong: "make dep" needs to be run to solve the issue.
#
# This might be broken, as She aspects seem to be ill-handled by the
# dependency graph generated by GHC.
#
# Pig takes its orders from HC_OPTS and build a BUILD_MODE. By
# default, this is a BUILD_DEV, with the corresponding DEV flags.
Pig: epigram
	rm -f $@
	$(HC) -o $@ $(HC_OPTS) $(OBJS)
	touch $(BUILD_MODE)

# Then, there are several flavors of build:

# Release: when compilation is slow, things go fast
release:
	$(MAKE) HC_OPTS="$(HC_OPTS_RELEASE)"\
	        BUILD_MODE="BUILD_RELEASE" Pig

# Test: with code coverage
btest:
	$(MAKE) HC_OPTS="$(HC_OPTS_TEST)"\
	        BUILD_MODE="BUILD_TEST" Pig

# Warning: cautious build mode
warning:
	$(MAKE) HC_OPTS="$(HC_OPTS_WARNING)"\
	        BUILD_MODE="BUILD_WARNING" Pig

# Profile: profiler enabled mode
profile:
	$(MAKE) HC_OPTS="$(HC_OPTS_PROFILE)"\
	        BUILD_MODE="BUILD_PROFILE" Pig


## Literate code:
# Try to stop as soon as possible, but it's still 2-3
# compilations. Rely on "Epitome.tex" to translate the literate code
# to latex.
#
# Look at the "tome" for a quick but dirty compilation of the Epitome
Epitome : Epitome.tex Epitome.bib
	$(LATEXC) $(LATEXOPTS) Epitome
	bibtex Epitome
	makeindex Epitome
	$(LATEXC) $(LATEXOPTS) Epitome
	if egrep Rerun Epitome.log; then $(LATEXC) $(LATEXOPTS) Epitome; fi

Epitome.tex : $(SRCS) stuff.fmt
	lhs2TeX --poly Epitome.lhs -o Epitome.tex

## Literate code in LaTeX:
# Same, with 'latex'
dvi : Epitome.dvi
Epitome.dvi : Epitome.tex
	latex Epitome
	bibtex Epitome
	makeindex Epitome
	latex Epitome
	if egrep Rerun Epitome.log; then latex Epitome; fi


## Literate code (in a hurry):
# To quickly check that no LaTeX bug has been introduced.
#
# However, the generated document will be incomplete wrt. references,
# bibliography entries, etc.
Atome:
	lhs2TeX --poly Epitome.lhs -o Epitome.tex
	pdflatex Epitome

## Unit testing (haha):
test:
	cd ../test && chmod +x test.sh && ./test.sh -q

## Tags (emacs):
etags:
	rm -f TAGS
	echo ":etags" | ghci $(HC_PACKAGE) -v0 Main.lhs
	while [ ! -f TAGS ]; do echo ":etags" | ghci $(HC_PACKAGE) -v0 Main.lhs; done

## Clean:
clean:
	rm -f $(SRCS:.lhs=.o)          \
	      $(SRCS:.lhs=.hers)       \
	      $(SRCS:.lhs=.hi)         \
	      $(SRCS:.lhs=.o-boot)     \
              $(SRCS:.lhs=.hi-boot)    \
	      BUILD_DEV                \
	      BUILD_RELEASE            \
	      BUILD_TEST               \
	      BUILD_WARNING            \
	      BUILD_PROFILE            \
	      *.aux *.bbl              \
	      *.blg *.log *.ptb        \
	      Epitome.tex              \
	      Epitome.toc


################################################################
# Automatic rules
################################################################

## Include the dependency graph
-include .depend

## Standard suffix rules

.o.hi:
	@:

%.o: %.hs
	$(HC) -c $< $(HC_OPTS)

%.o: %.lhs
ifeq ($(or $(if $(wildcard BUILD_*),,1), \
	   $(wildcard $(BUILD_MODE))),)
	# Previous .o files might be left from a previous build mode
	$(error "Messing up different builds. Please 'make clean'.")
endif
	# $(HC) --make $< $(HC_OPTS)
	$(HC) -c $< $(HC_OPTS)

.o-boot.hi-boot:
	@:

.lhs-boot.o-boot:
	$(HC) -c $< $(HC_OPTS)
