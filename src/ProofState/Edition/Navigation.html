<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title></title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; }
code > span.dt { color: #902000; }
code > span.dv { color: #40a070; }
code > span.bn { color: #40a070; }
code > span.fl { color: #40a070; }
code > span.ch { color: #4070a0; }
code > span.st { color: #4070a0; }
code > span.co { color: #60a0b0; font-style: italic; }
code > span.ot { color: #007020; }
code > span.al { color: #ff0000; font-weight: bold; }
code > span.fu { color: #06287e; }
code > span.er { color: #ff0000; font-weight: bold; }
  </style>
</head>
<body>
<h1 id="sec:Proofstate.Edition.Navigation">Navigating in the Proof Context</h1>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">{-# OPTIONS_GHC -F -pgmF she #-}</span>
<span class="co">{-# LANGUAGE FlexibleInstances, TypeOperators, TypeSynonymInstances,</span>
<span class="co">             GADTs, RankNTypes #-}</span>
<span class="kw">module</span> <span class="dt">ProofState.Edition.Navigation</span> <span class="kw">where</span>
<span class="kw">import </span><span class="dt">Control.Applicative</span>
<span class="kw">import </span><span class="dt">Control.Monad.Except</span>
<span class="kw">import </span><span class="dt">Data.Traversable</span>
<span class="kw">import </span><span class="dt">Kit.BwdFwd</span>
<span class="kw">import </span><span class="dt">Kit.MissingLibrary</span>
<span class="kw">import </span><span class="dt">ProofState.Structure.Developments</span>
<span class="kw">import </span><span class="dt">ProofState.Structure.Entries</span>
<span class="kw">import </span><span class="dt">ProofState.Edition.ProofContext</span>
<span class="kw">import </span><span class="dt">ProofState.Edition.Entries</span>
<span class="kw">import </span><span class="dt">ProofState.Edition.News</span>
<span class="kw">import </span><span class="dt">ProofState.Edition.ProofState</span>
<span class="kw">import </span><span class="dt">ProofState.Edition.GetSet</span>
<span class="kw">import </span><span class="ot">{-# SOURCE #-}</span> <span class="dt">Elaboration.Wire</span>
<span class="kw">import </span><span class="dt">Evidences.Tm</span></code></pre>
<p>In Section [sec:ProofState.Structure.Developments], we have developed the notion of |Development|, a tree reifing the proof construction process. In order to navigate this tree, we have computed its zipper in Section [sec:ProofState.Edition.ProofContext], the |ProofContext|. At this stage, we have a notion of <em>movement</em> in the proof context.</p>
<p>However, we had to postpone the development of navigation commands to this stage, where we have the ability to <em>edit</em> the |ProofState| (Section [sec:ProofState.Edition.ProofState]). Indeed, when moving down, we might hit a news bulletin. A news bulletin is a lazy edition process. In order to move, we have to propogate the news, hence effectively editing the proof state.</p>
<h2 id="one-step-navigation">One-step navigation</h2>
<p>We shall now develop this navigation kit, comfortably installed in the |ProofState| monad. First, some vocabulary. The <em>focus</em> is the current development; it contains a <em>cursor</em> which is the point at which changes take place. Consider the following development presented in Figure [fig:ProofState.Edition.Navigation.devpmt]: we have that the development |B| is in focus, with |y| above the cursor and |z| below it.</p>
<p><span>3.3cm</span></p>
<pre><code>[
  A [
    I : S
    \ e : S
    \ f : S
  ] : S
  \ u : S
  \ v : S
  B [
    D := ? : S
    \ x : S
    E [
      \ a : S
      F := ? : S
      \ b : S
    ] : S
    \ y : S
    -= Cursor here =-
    \ z : S 
  ] : S
  \ w : S
  C [
    \ g : S
    H := ? : S
    \ h : S
  ] : S
  G := ? : S
]</code></pre>
<p>[fig:navigation-devpmt-example]</p>
<p><span>3.3cm</span></p>
<pre><code>[
  A [
    I : S
    \ e : S
    \ f : S
  ] : S
  \ u : S
  \ v : S
  B [
    D := ? : S
    \ x : S
    E [
      \ a : S
      F := ? : S
      \ b : S
    ] : S
    -= Cursor here =-
    \ y : S
    \ z : S 
  ] : S
  \ w : S
  C [
    \ g : S
    H := ? : S
    \ h : S
  ] : S
  G := ? : S
]</code></pre>
<p>[fig:navigation-devpmt-cursorUp]</p>
<p><span>3.3cm</span></p>
<pre><code>[
  A [
    I : S
    \ e : S
    \ f : S
  ] : S
  \ u : S
  \ v : S
  B [
    D := ? : S
    \ x : S
    E [
      \ a : S
      F := ? : S
      \ b : S
    ] : S
    \ y : S
    \ z : S 
    -= Cursor here =-
  ] : S
  \ w : S
  C [
    \ g : S
    H := ? : S
    \ h : S
  ] : S
  G := ? : S
]</code></pre>
<p>[fig:navigation-devpmt-cursordown]</p>
<p><span>3.3cm</span></p>
<pre><code>[
  A [
    I : S
    \ e : S
    \ f : S
  ] : S
  \ u : S
  \ v : S
  B [
    D := ? : S
    \ x : S
    E [
      \ a : S
      F := ? : S
      \ b : S
      -= Cursor here =-
    ] : S
    \ y : S
    \ z : S 
  ] : S
  \ w : S
  C [
    \ g : S
    H := ? : S
    \ h : S
  ] : S
  G := ? : S
]</code></pre>
<p>[fig:navigation-devpmt-goin]</p>
<p><span>3.3cm</span></p>
<pre><code>[
  A [
    I : S
    \ e : S
    \ f : S
  ] : S
  \ u : S
  \ v : S
  B [
    D := ? : S
    \ x : S
    E [
      \ a : S
      F := ? : S
      \ b : S
    ] : S
    \ y : S
    \ z : S 
  ] : S
  \ w : S
  C [
    \ g : S
    H := ? : S
    \ h : S
  ] : S
  G := ? : S
  -= Cursor here =-
]</code></pre>
<p>[fig:navigation-devpmt-goout]</p>
<p><span>3.3cm</span></p>
<pre><code>[
  A [
    I : S
    \ e : S
    \ f : S
  ] : S
  \ u : S
  \ v : S
  B [
    D := ? : S
    \ x : S
    E [
      \ a : S
      F := ? : S
      \ b : S
    ] : S
    \ y : S
    \ z : S 
  ] : S
  -= Cursor here =-
  \ w : S
  C [
    \ g : S
    H := ? : S
    \ h : S
  ] : S
  G := ? : S
]</code></pre>
<p>[fig:navigation-devpmt-gooutbelow]</p>
<p><span>3.3cm</span></p>
<pre><code>[
  A [
    I : S
    \ e : S
    \ f : S
    -= Cursor here =-
  ] : S
  \ u : S
  \ v : S
  B [
    D := ? : S
    \ x : S
    E [
      \ a : S
      F := ? : S
      \ b : S
    ] : S
    \ y : S
    \ z : S 
  ] : S
  \ w : S
  C [
    \ g : S
    H := ? : S
    \ h : S
  ] : S
  G := ? : S
]</code></pre>
<p>[fig:navigation-devpmt-goup]</p>
<p><span>3.3cm</span></p>
<pre><code>[
  A [
    I : S
    \ e : S
    \ f : S
  ] : S
  \ u : S
  \ v : S
  B [
    D := ? : S
    \ x : S
    E [
      \ a : S
      F := ? : S
      \ b : S
    ] : S
    \ y : S
    \ z : S 
  ] : S
  \ w : S
  C [
    \ g : S
    H := ? : S
    \ h : S
    -= Cursor here =-
  ] : S
  G := ? : S
]</code></pre>
<p>[fig:navigation-devpmt-godown]</p>
<p>[fig:ProofState.Edition.Navigation.devpmt]</p>
<p>The navigation commands are the following:</p>
<ul>
<li><p>Current entry navigation:</p>
<ul>
<li><p>|putEnterCurrent|</p></li>
<li><p>|leaveEnterCurrent|</p></li>
</ul></li>
<li><p>Cursor navigation:</p>
<ul>
<li><p>|cursorUp| moves the cursor up by one entry (under |E| in the example);</p></li>
<li><p>|cursorDown| moves the cursor down by one entry (under |z| in the example);</p></li>
</ul></li>
<li><p>Focus navigation:</p>
<ul>
<li><p>|goIn| moves the focus in the first definition above the cursor, and brings the cursor at the bottom of the newly focused development (inside |E| and below |b| in the example);</p></li>
<li><p>|goOut| moves the focus out to the development that contains it, with the cursor at the bottom of the development (under |G| in the example);</p></li>
<li><p>|goOutBelow| moves the focus out to the development that contains it, with the cursor under the previously focused entry (under |B| in the example);</p></li>
<li><p>|goUp| moves the focus up to the closest definition and leaves the cursor at the bottom (inside |A| in the example); and</p></li>
<li><p>|goDown| moves the focus down to the closest definition and leaves the cursor at the bottom (inside |C| in the example).</p></li>
</ul></li>
</ul>
<p>These commands fail with an error if they are impossible because the proof context is not in the required form. Things are slightly more complicated than the above description because of the possibility of news bulletins below the cursor; as these are propagated lazily, they must be pushed down when the cursor or focus move.</p>
<p>From Entry to Current entry, and back</p>
<p>With |getCurrentEntry| and |putCurrentEntry|, we know how to access the current entry, and overwrite it. However, when navigating through the proof context, we will change focus, therefore <em>leaving</em> the current entry, or <em>entering</em> into another.</p>
<p>When leaving the current entry, the current entry is turned back into a conventional entry, so that it can be inserted with its peers in the development (above or below). In a word, this operation <em>zip</em> back the current entry.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">getLeaveCurrent ::</span> <span class="dt">ProofState</span> (<span class="dt">Entry</span> <span class="dt">Bwd</span>)
getLeaveCurrent <span class="fu">=</span> <span class="kw">do</span>
    currentEntry <span class="ot">&lt;-</span> getCurrentEntry
    <span class="dt">Dev</span> above tip root state <span class="ot">&lt;-</span> getAboveCursor
    below <span class="ot">&lt;-</span> getBelowCursor
    <span class="kw">let</span> dev <span class="fu">=</span> <span class="dt">Dev</span> (above <span class="fu">&lt;&gt;&lt;</span> below) tip root state
    <span class="kw">case</span> currentEntry <span class="kw">of</span>
        <span class="dt">CDefinition</span> dkind ref xn ty a  <span class="ot">-&gt;</span>  return <span class="fu">$</span> <span class="dt">EDEF</span> ref xn dkind dev ty a
        <span class="dt">CModule</span> n                      <span class="ot">-&gt;</span>  return <span class="fu">$</span> <span class="dt">EModule</span> n dev</code></pre>
<p>Conversely, when entering a new development, the former entry needs to be <em>unzipped</em> to form the current development.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">putEnterCurrent ::</span> <span class="dt">Entry</span> <span class="dt">Bwd</span> <span class="ot">-&gt;</span> <span class="dt">ProofState</span> ()
putEnterCurrent (<span class="dt">EDEF</span> ref xn dkind dev ty a) <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> getLayer
    replaceLayer <span class="fu">$</span> l { currentEntry <span class="fu">=</span> <span class="dt">CDefinition</span> dkind ref xn ty a}
    putAboveCursor dev
putEnterCurrent (<span class="dt">EModule</span> [] dev) <span class="fu">=</span> putAboveCursor dev
putEnterCurrent (<span class="dt">EModule</span> n dev) <span class="fu">=</span> <span class="kw">do</span>
    l <span class="ot">&lt;-</span> getLayer
    replaceLayer <span class="fu">$</span> l { currentEntry <span class="fu">=</span> <span class="dt">CModule</span> n }
    putAboveCursor dev</code></pre>
<p>Cursor navigation</p>
<p>Cursor movement is straightforward, as there is no news to worry about. We simply move an entry above the cursor to one below, or vice versa.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">cursorUp ::</span> <span class="dt">ProofState</span> ()
cursorUp <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- Look above</span>
    above <span class="ot">&lt;-</span> getEntriesAbove
    <span class="kw">case</span> above <span class="kw">of</span>
        aboveE <span class="fu">:&lt;</span> e <span class="ot">-&gt;</span> <span class="kw">do</span>
            below <span class="ot">&lt;-</span> getBelowCursor
            <span class="co">-- Move |e| from |above| to |below|</span>
            putEntriesAbove aboveE
            putBelowCursor <span class="fu">$</span> e <span class="fu">:&gt;</span> below
            return ()
        <span class="dt">B0</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
            <span class="co">-- There is no above..</span>
            throwError <span class="fu">$</span> sErr <span class="st">&quot;cursorUp: cannot move cursor up.&quot;</span>
<span class="ot">cursorDown ::</span> <span class="dt">ProofState</span> ()
cursorDown <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- Look below</span>
    above <span class="ot">&lt;-</span> getEntriesAbove
    below <span class="ot">&lt;-</span> getBelowCursor
    <span class="kw">case</span> below <span class="kw">of</span>
        e <span class="fu">:&gt;</span> belowE <span class="ot">-&gt;</span> <span class="kw">do</span>
            <span class="co">-- Move |e| from |below| to |above|</span>
            putEntriesAbove (above <span class="fu">:&lt;</span> e)
            putBelowCursor belowE
            return ()
        <span class="dt">F0</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
            <span class="co">-- There is no below..</span>
            throwError <span class="fu">$</span> sErr <span class="st">&quot;cursorDown: cannot move cursor down.&quot;</span></code></pre>
<p>Focus navigation</p>
<p>The |goIn| command moves the cursor upward, until it reaches a definition. If one can be found, it enters it and goes at the bottom.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">goIn ::</span> <span class="dt">ProofState</span> ()
goIn <span class="fu">=</span> <span class="kw">do</span>
    above <span class="ot">&lt;-</span> getEntriesAbove
    <span class="kw">case</span> above <span class="kw">of</span>
        <span class="dt">B0</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
          <span class="co">-- Nothing above: we cannot go above</span>
          throwError <span class="fu">$</span> sErr <span class="st">&quot;goIn: you can&#39;t go that way.&quot;</span>
        aboveE <span class="fu">:&lt;</span> e <span class="ot">-&gt;</span> <span class="kw">case</span> entryDev e <span class="kw">of</span>
          <span class="dt">Nothing</span>   <span class="ot">-&gt;</span> <span class="kw">do</span>
             <span class="co">-- This entry is not a Definition: look further up</span>
             cursorUp <span class="fu">&gt;&gt;</span> goIn
          <span class="dt">Just</span> dev  <span class="ot">-&gt;</span> <span class="kw">do</span>
             <span class="co">-- We are right into a Definition</span>
             oldFocus  <span class="ot">&lt;-</span> getAboveCursor
             below  <span class="ot">&lt;-</span> getBelowCursor
             <span class="co">-- Set the focus to this Definition</span>
             putLayer <span class="fu">$</span> <span class="dt">Layer</span>  {  aboveEntries <span class="fu">=</span> aboveE
                               ,  currentEntry <span class="fu">=</span> mkCurrentEntry e
                               ,  belowEntries <span class="fu">=</span> reverseEntries below
                               ,  layTip <span class="fu">=</span> devTip oldFocus
                               ,  layNSupply <span class="fu">=</span> devNSupply oldFocus
                               ,  laySuspendState <span class="fu">=</span> devSuspendState oldFocus }
             <span class="co">-- Set cursor at the bottom</span>
             putAboveCursor dev
             putBelowCursor <span class="dt">F0</span>
             return ()</code></pre>
<p>The |goOut| command moves the focus to the outer layer, with the cursor at the bottom of it. Therefore, we zip back the current development, with the additional burden of dealing with news.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">goOut ::</span> <span class="dt">ProofState</span> ()
goOut <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- Leave the current entry</span>
    e <span class="ot">&lt;-</span> getLeaveCurrent
    <span class="co">-- Move one layer out</span>
    mLayer <span class="ot">&lt;-</span> optional removeLayer
    <span class="kw">case</span> mLayer <span class="kw">of</span>
        <span class="dt">Just</span> l <span class="ot">-&gt;</span> <span class="kw">do</span>
            <span class="co">-- Update the current development</span>
            putAboveCursor <span class="fu">$</span> <span class="dt">Dev</span>  {  devEntries       <span class="fu">=</span>  aboveEntries l <span class="fu">:&lt;</span> e
                                  ,  devTip           <span class="fu">=</span>  layTip l
                                  ,  devNSupply       <span class="fu">=</span>  layNSupply l
                                  ,  devSuspendState  <span class="fu">=</span>  laySuspendState l }
            putBelowCursor <span class="dt">F0</span>
            propagateNews <span class="dt">NormalPropagate</span> [] (belowEntries l)
            <span class="co">-- Here, the cursor is at the bottom of the current development</span>
            return ()
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
            <span class="co">-- Already at outermost position</span>
            throwError <span class="fu">$</span> sErr <span class="st">&quot;goOut: you can&#39;t go that way.&quot;</span></code></pre>
<p>The |goOutBelow| variant has a similar effect than |goOut|, excepted that it brings the cursor right under the previous point of focus.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">goOutBelow ::</span> <span class="dt">ProofState</span> ()
goOutBelow <span class="fu">=</span> <span class="kw">do</span>
    <span class="co">-- Retrieve the number of entries below the previous point of focus</span>
    ls <span class="ot">&lt;-</span> getLayers
    <span class="kw">case</span> ls <span class="kw">of</span>
        _ <span class="fu">:&lt;</span> <span class="dt">Layer</span>{belowEntries<span class="fu">=</span>below} <span class="ot">-&gt;</span> <span class="kw">do</span>
            <span class="co">-- Go out: end up at the bottom of the development</span>
            goOut
            <span class="co">-- Move cursor up by as many entries there was</span>
            Data.Traversable.mapM (const cursorUp) below
            return ()
        <span class="dt">B0</span> <span class="ot">-&gt;</span> throwError <span class="fu">$</span> sErr <span class="st">&quot;goOutBelow: you can&#39;t go that way.&quot;</span></code></pre>
<p>The |goUp| command moves the focus upward, looking for a definition. If one can be found, the cursor is moved at the bottom of the new development.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">goUp ::</span> <span class="dt">ProofState</span> ()
goUp <span class="fu">=</span> goUpAcc (<span class="dt">NF</span> <span class="dt">F0</span>)
  <span class="kw">where</span>
<span class="ot">    goUpAcc ::</span> <span class="dt">NewsyEntries</span> <span class="ot">-&gt;</span> <span class="dt">ProofState</span> ()
    goUpAcc (<span class="dt">NF</span> visitedBelow) <span class="fu">=</span> <span class="kw">do</span>
        <span class="co">-- Get the directly enclosing layer</span>
        l <span class="ot">&lt;-</span> getLayer
        <span class="kw">case</span> l <span class="kw">of</span>
          (<span class="dt">Layer</span> (aboveE <span class="fu">:&lt;</span> e) m (<span class="dt">NF</span> below) tip nsupply state) <span class="ot">-&gt;</span>
            <span class="co">-- It has at least one entry</span>
            <span class="kw">case</span> entryDev e <span class="kw">of</span>
            <span class="dt">Just</span> dev <span class="ot">-&gt;</span> <span class="kw">do</span>
                <span class="co">-- The entry is a Definition</span>
                <span class="co">-- Leave our current position</span>
                currentE <span class="ot">&lt;-</span> getLeaveCurrent
                <span class="co">-- Put the cursor at the bottom of the development</span>
                putAboveCursor dev
                putBelowCursor <span class="dt">F0</span>
                <span class="co">-- Set focus on this definition</span>
                <span class="kw">let</span> belowE <span class="fu">=</span> <span class="dt">NF</span>  <span class="fu">$</span>    visitedBelow
                                 <span class="fu">&lt;+&gt;</span>  (<span class="dt">Right</span> (reverseEntry currentE) <span class="fu">:&gt;</span> below)
                replaceLayer <span class="fu">$</span> l  {  aboveEntries  <span class="fu">=</span>  aboveE
                                  ,  currentEntry  <span class="fu">=</span>  mkCurrentEntry e
                                  ,  belowEntries  <span class="fu">=</span>  belowE}
                return ()
            <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="kw">do</span>
                <span class="co">-- The entry is a Parameter</span>
                <span class="co">-- Move up, accumulating the the current entry</span>
                replaceLayer <span class="fu">$</span> l { aboveEntries <span class="fu">=</span> aboveE }
                goUpAcc <span class="fu">$</span> <span class="dt">NF</span> (<span class="dt">Right</span> (reverseEntry e) <span class="fu">:&gt;</span> visitedBelow)
          _ <span class="ot">-&gt;</span> <span class="kw">do</span>
            <span class="co">-- There is no up</span>
            throwError <span class="fu">$</span> sErr <span class="st">&quot;goUp: you can&#39;t go that way.&quot;</span></code></pre>
<p>Similarly to |goUp|, the |goDown| command moves the focus downward, looking for a definition. If one can be found, the cursor is placed at the bottom of the new development. As often, moving down implies dealing with news: we accumulate them as we go, updating the parameteres on our way.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">goDown ::</span> <span class="dt">ProofState</span> ()
goDown <span class="fu">=</span> goDownAcc <span class="dt">B0</span> []
  <span class="kw">where</span>
<span class="ot">    goDownAcc ::</span> <span class="dt">Entries</span> <span class="ot">-&gt;</span> <span class="dt">NewsBulletin</span> <span class="ot">-&gt;</span> <span class="dt">ProofState</span> ()
    goDownAcc visitedAbove visitedNews <span class="fu">=</span> <span class="kw">do</span>
        <span class="co">-- Get the directly enclosing layer</span>
        l <span class="ot">&lt;-</span> getLayer
        <span class="kw">case</span> l <span class="kw">of</span>
          (<span class="dt">Layer</span> {aboveEntries <span class="fu">=</span> above , belowEntries<span class="fu">=</span><span class="dt">NF</span> (ne <span class="fu">:&gt;</span> belowNE)}) <span class="ot">-&gt;</span>
            <span class="co">-- What is the entry below?</span>
            <span class="kw">case</span> ne <span class="kw">of</span>
            <span class="dt">Left</span> newsBulletin <span class="ot">-&gt;</span> <span class="kw">do</span>
                <span class="co">-- A news bulletin:</span>
                <span class="co">-- Keep going down, accumulating the news</span>
                replaceLayer <span class="fu">$</span> l { belowEntries <span class="fu">=</span> <span class="dt">NF</span> belowNE }
                goDownAcc visitedAbove <span class="fu">$</span> mergeNews visitedNews newsBulletin
            <span class="dt">Right</span> e <span class="ot">-&gt;</span>
                <span class="co">-- A real entry:</span>
                <span class="co">-- Definition or Parameter?</span>
                <span class="kw">case</span> entryCoerce e <span class="kw">of</span>
                <span class="dt">Left</span> (<span class="dt">Dev</span> es&#39; tip&#39; nsupply&#39; ss&#39;) <span class="ot">-&gt;</span> <span class="kw">do</span>
                  <span class="co">-- Definition:</span>
                  <span class="co">-- Leave our current position</span>
                  currentE <span class="ot">&lt;-</span> getLeaveCurrent
                  <span class="co">-- Set focus on this definition</span>
                  <span class="kw">let</span> aboveE <span class="fu">=</span> (above <span class="fu">:&lt;</span> currentE) <span class="fu">&lt;+&gt;</span> visitedAbove
                  replaceLayer <span class="fu">$</span> l  {  aboveEntries  <span class="fu">=</span>  aboveE
                                    ,  currentEntry  <span class="fu">=</span>  mkCurrentEntry e
                                    ,  belowEntries  <span class="fu">=</span>  <span class="dt">NF</span> belowNE }
                  <span class="co">-- Put the cursor at the bottom of the development</span>
                  <span class="co">-- The suspend state is cleared because there are no</span>
                  <span class="co">-- entries in the |Dev|; the state will be updated</span>
                  <span class="co">-- during news propagation.</span>
                  putAboveCursor (<span class="dt">Dev</span> <span class="dt">B0</span> tip&#39; nsupply&#39; <span class="dt">SuspendNone</span>)
                  putBelowCursor <span class="dt">F0</span>
                  <span class="co">-- Push the collected news from above into the entries</span>
                  propagateNews <span class="dt">NormalPropagate</span> visitedNews es&#39;
                  return ()
                <span class="dt">Right</span> param <span class="ot">-&gt;</span> <span class="kw">do</span>
                  <span class="co">-- Parameter:</span>
                  <span class="co">-- Push the news into it</span>
                  (news, param&#39;) <span class="ot">&lt;-</span> tellEntry visitedNews param
                  <span class="co">-- Keep going down</span>
                  replaceLayer  <span class="fu">$</span> l { belowEntries <span class="fu">=</span> <span class="dt">NF</span> belowNE }
                  goDownAcc (visitedAbove <span class="fu">:&lt;</span> param&#39;) news
          _ <span class="ot">-&gt;</span> <span class="kw">do</span>
            <span class="co">-- There is no down</span>
            throwError <span class="fu">$</span> sErr <span class="st">&quot;goDown: you can&#39;t go that way.&quot;</span></code></pre>
<h2 id="many-step-navigation">Many-step Navigation</h2>
<p>The following functions are trivial iterations of the ones developed above.</p>
<pre class="sourceCode literate haskell"><code class="sourceCode haskell"><span class="ot">cursorTop ::</span> <span class="dt">ProofState</span> ()
cursorTop <span class="fu">=</span> much cursorUp
<span class="ot">cursorBottom ::</span> <span class="dt">ProofState</span> ()
cursorBottom <span class="fu">=</span> much cursorDown
<span class="ot">goTop ::</span> <span class="dt">ProofState</span> ()
goTop <span class="fu">=</span> much goUp
<span class="ot">goBottom ::</span> <span class="dt">ProofState</span> ()
goBottom <span class="fu">=</span> much goDown
<span class="ot">goRoot ::</span> <span class="dt">ProofState</span> ()
goRoot <span class="fu">=</span> much goOut</code></pre>
</body>
</html>
